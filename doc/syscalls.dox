/*
 * Copyright (c) 2023 Rhys Weatherley
 *
 * Licensed under the Apache License, Version 2.0 with LLVM Exceptions,
 * See https://github.com/rweater/mosnix/blob/main/LICENSE for license
 * information.
 */

/**
\file syscalls.dox
\page syscalls System call interface for MOSnix

The general approach of the system call interface of MOSnix is to let the
[llvm-mos C calling conventions](https://llvm-mos.org/wiki/C_calling_convention)
do most of the heavy lifting.

The llvm-mos compiler uses 32 <i>imaginary registers</i>
<tt>rc0</tt> ... <tt>rc31</tt> to pass parameters to functions,
return results, and store local variables.  If the compiler runs out of
imaginary registers, then it will pass extra parameters on the C stack
(which is not the same as the 6502's return address stack).

The first parameter to a function is usually passed in the A:X register
pair.  The top of stack is pointed to by the register pair <tt>rc0:rc1</tt>

The kernel and the user space processes each have their own separate
copy of the imaginary registers and the stack.  A method is needed to
pass values back and forth across the system call boundary without
imposing too much overhead.

The <tt>syscall()</tt> function in <tt>&lt;sys/syscall.h&gt;</tt>
has the following prototype:

\code
int syscall(unsigned char number, ...);
\endcode

The llvm-mos C calling conventions will arrange for all of the arguments
in the ellipsis <tt>...</tt> to be passed on the C stack.  The top of C
stack is pointed to by the imaginary register pair <tt>rc0:rc1</tt>
and the system call number will be in the A register.

The <tt>syscall()</tt> function is used as follows to define system call
wrapper functions:

\code
ssize_t read(int fd, void *data, size_t size)
{
    return syscall(SYS_read, fd, data, size);
}
\endcode

Behind the scenes, llvm-mos arranges to set A to <tt>SYS_read</tt> and to
place the arguments on the C stack.  The <tt>syscall()</tt> function then
performs the following pseudocode to call into the kernel:

\verbatim
Y = A * 2
A:X = rc0:rc1
jsr SYSCALL
if (A:X < 0) {
    errno = -A:X
    return -1
} else {
    return A:X
}
\endverbatim

The system call number is doubled and copied into Y.  The doubling helps the
kernel by making Y an offset into the system call dispatch table.  If we
leave this to later, then more register juggling is required inside the kernel.
It is easier to make the user space application do the doubling.

The top of stack pointer in <tt>rc0:rc1</tt> is transferred to A:X
so that it can be passed to the kernel system call as a pointer to a
<tt>struct</tt> containing the parameters.

The <tt>SYSCALL</tt> symbol is exported by the kernel to allow user
applications to figure out where the dispatcher is located.

Inside the kernel, the system call is implemented as follows:

\code
struct sys_read_s {
    int fd;
    void *data;
    size_t size;
};

int sys_read(struct sys_read_s *args)
{
    ...
}
\endcode

The kernel can use its own imaginary registers and C stack to implement
the system call.  The llvm-mos handling of variadic functions has already
packed the values into a <tt>struct</tt> for the system call.  The only thing
that is shared is the 6502's return address stack.

System calls that return results greater than 16 bits in size must
pass a pointer to a return variable to the kernel.  For example:

\code
off_t lseek(int fd, off_t offset, int whence)
{
    off_t result;
    if (syscall(SYS_lseek, fd, offset, whence, &result) == 0)
        return result;
    else
        return -1;
}
\endcode

*/
